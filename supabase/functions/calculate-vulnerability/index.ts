import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

serve(async (req) => {
  if (req.method === 'OPTIONS') return new Response(null, { headers: corsHeaders });
  
  try {
    const supabase = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_ANON_KEY") ?? "",
      { global: { headers: { Authorization: req.headers.get("Authorization")! } } }
    );

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error("Unauthorized");

    console.log("Calculating vulnerability scores...");
    
    // Fetch latest data from all sources
    const { data: healthData } = await supabase
      .from('health_data')
      .select('country, severity_index, risk_level')
      .order('created_at', { ascending: false })
      .limit(100);

    const { data: foodData } = await supabase
      .from('food_security')
      .select('country, risk')
      .order('created_at', { ascending: false })
      .limit(100);

    const { data: energyData } = await supabase
      .from('energy_grid')
      .select('country, outage_risk, stability_index')
      .order('created_at', { ascending: false })
      .limit(100);

    const { data: popData } = await supabase
      .from('population_data')
      .select('country, population, latitude, longitude')
      .order('created_at', { ascending: false })
      .limit(100);

    const { data: crisisData } = await supabase
      .from('crisis_events')
      .select('country, severity')
      .eq('status', 'active');

    // Aggregate by country
    const countryData = new Map();

    const addCountryData = (country: string, field: string, value: any) => {
      if (!countryData.has(country)) {
        countryData.set(country, { country });
      }
      countryData.get(country)[field] = value;
    };

    // Process health data
    healthData?.forEach(h => {
      const riskMap: any = { 'low': 20, 'medium': 50, 'high': 80, 'critical': 100 };
      addCountryData(h.country, 'health_risk', riskMap[h.risk_level] || h.severity_index || 0);
    });

    // Process food data
    foodData?.forEach(f => {
      const riskMap: any = { 'low': 20, 'medium': 50, 'high': 80, 'critical': 100 };
      addCountryData(f.country, 'food_risk', riskMap[f.risk] || 0);
    });

    // Process energy data
    energyData?.forEach(e => {
      const energyRisk = (e.outage_risk || 0) + (100 - (e.stability_index || 100));
      addCountryData(e.country, 'energy_risk', Math.min(100, energyRisk));
    });

    // Process population data
    popData?.forEach(p => {
      addCountryData(p.country, 'population', p.population);
      addCountryData(p.country, 'latitude', p.latitude);
      addCountryData(p.country, 'longitude', p.longitude);
    });

    // Process crisis data
    const crisisCounts = new Map();
    crisisData?.forEach(c => {
      const count = crisisCounts.get(c.country) || 0;
      const severityMap: any = { 'low': 10, 'medium': 25, 'high': 50, 'critical': 100 };
      crisisCounts.set(c.country, count + (severityMap[c.severity] || 0));
    });

    crisisCounts.forEach((score, country) => {
      addCountryData(country, 'climate_risk', Math.min(100, score));
    });

    // Calculate overall scores
    const vulnerabilityRecords = Array.from(countryData.values()).map(data => {
      const healthRisk = data.health_risk || 0;
      const foodRisk = data.food_risk || 0;
      const energyRisk = data.energy_risk || 0;
      const climateRisk = data.climate_risk || 0;
      const economicRisk = 50; // Placeholder - integrate economic indicators

      // Weighted composite score
      const overallScore = (
        healthRisk * 0.25 +
        foodRisk * 0.25 +
        energyRisk * 0.20 +
        climateRisk * 0.20 +
        economicRisk * 0.10
      );

      const confidence = [healthRisk, foodRisk, energyRisk, climateRisk, economicRisk]
        .filter(v => v > 0).length / 5 * 100;

      return {
        country: data.country,
        region: data.country,
        latitude: data.latitude || 0,
        longitude: data.longitude || 0,
        overall_score: Math.round(overallScore),
        health_risk: healthRisk,
        food_risk: foodRisk,
        energy_risk: energyRisk,
        climate_risk: climateRisk,
        economic_risk: economicRisk,
        population_affected: data.population || 0,
        confidence: Math.round(confidence),
        factors: {
          data_sources: ['health', 'food', 'energy', 'climate', 'economic'].filter((_, i) => 
            [healthRisk, foodRisk, energyRisk, climateRisk, economicRisk][i] > 0
          )
        }
      };
    });

    if (vulnerabilityRecords.length > 0) {
      const { error: insertError } = await supabase
        .from('vulnerability_scores')
        .insert(vulnerabilityRecords);

      if (insertError) throw insertError;
    }

    await supabase.from('system_logs').insert({
      division: 'analytics',
      action: 'vulnerability_calculation',
      result: 'success',
      log_level: 'info',
      metadata: { 
        countries_processed: vulnerabilityRecords.length,
        avg_score: vulnerabilityRecords.reduce((sum, r) => sum + r.overall_score, 0) / vulnerabilityRecords.length
      }
    });

    return new Response(
      JSON.stringify({ 
        ok: true, 
        message: `Calculated vulnerability for ${vulnerabilityRecords.length} countries`,
        records: vulnerabilityRecords
      }), 
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (e) {
    console.error("calculate-vulnerability error:", e);
    return new Response(
      JSON.stringify({ error: e instanceof Error ? e.message : 'Unknown error' }), 
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
